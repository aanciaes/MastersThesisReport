%!TEX root = ../template.tex

\chapter{Prototype Implementation}
\label{cha:elaboration_plan}

This chapter presents a detailed explanation of the implementation of the prototype - A Trusted and Privacy-Enhanced In-Memory Data Store, and all the implementation details that helped the system to achieve a secure state according to the adversary model.

Section \ref{sec:architecture_implementation_options} explains the system model presented on figure \ref{fig:system_model_overview} from a developer view, and presents all used technologies, programming languages and implementation details used to achieve the desired system.

Section \ref{sec:additional_security_features} presents some general additional security and implementation features also worth mentioning and in section \ref{sec:tradeoffs_implementation_options} it is explained some tradeoffs decided in the implementation of the prototype, and why where they made. 

To finalise, there is a general summary if the chapter in section \ref{sec:chapter4_summary} that gathers all important implementation features from all components.

The implemented prototype source code is available publicly on GitHub, secure datastore, \cite{thesis-repository:container}, the proxy \cite{thesis-repository:proxy} and the client/tester \cite{thesis-repository:client}.

\section{Architecture and Implementation Options}
\label{sec:architecture_implementation_options}

To achieve the goal of deploying the system in a cloud, we had to find a provider that has and provides host machines with the pretended \gls{TEE} technology - Intel's Software Guard Extensions (\gls{SGX}) v2.11. Although not globally available, some cloud providers are starting to make them available and for this thesis, the cloud provider used is OVH Cloud \cite{ovhcloud:1}. 

For this thesis, OVH provided an IaaS stack machine running Ubuntu Server version 18.04 with kernel 4.15.0-101-generic, which means that we have control over all host's stack but the hardware, from the operating system, networks, runtime and applications. The used machine specific configurations are listed on listing \ref{lst:ovh_machine_specs}.

\lstset{numbers=none, caption=Machine Specifications, label=lst:machine_specs}
\label{lst:ovh_machine_specs}
\begin{lstlisting}
Dedicated Server Node
Processor: Intel 2x Xeon Silver 4214 - 24c/48t - 2.2GHz/3.2Ghz
Memory: 192 GB
Hard Drive: NVMe, SATA available
Public Network: Beginning at 1 Gbps
Private Network: Beginning at 2 Gbps
CloudLinux (Ubuntu 18.04 LTS Server 64 bits)
\end{lstlisting}

This particular Intel processor offers \gls{SGX} with an 128\gls{MB} of enclave page cache (\gls{EPC}) with about 94\gls{MB} being available for application use like explained in section \ref{ssec:circumvention_of_sgx_limitations} and all \gls{SGX} linux drivers and \glspl{SDK} were installed \cite{sgx_drivers:1, sgx_sdk:1}.

All components of the application will be deployed using Docker v19.03.6 \cite{docker:1} and the Docker Compose tool v1.17.1 \cite{docker-compose:1}. To integrate and run unmodified applications with \gls{SGX}, the SCONE v4.2.1 \cite{scone:1} technology was used, and will wrap all components that need to run within a secure and isolated environment.

\subsection{Secure Redis}
\label{ssec:secure_redis}

Redis \cite{redis:1} is the key-value storage server used by this thesis. Redis instances will run in two different modes, as explained in section \ref{ssec:key-value_storage_server}. Unsecure Redis configuration will run on unprotected memory on a docker image based on the official Redis Docker repository \cite{redis:6}. For the secure configuration, SCONE framework already provides a curated image from their repository which contains a Redis server version 6.0-rc1 ready to run on an isolated environment, in this case Intel's SGX. The SCONE version used is the SCONE 4.2.1 to match across all the SCONE components.

Although all redis servers run behind a proxy all the necessary security features provided natively by the server are used. Only communications incoming from the proxy server are allowed and all are encrypted with strong \gls{TLS} 1.3 \footnote{TLS is a new feature released in Redis v6.0} protocols with enclave termination. The non encrypted communication port is disabled, and mutual \gls{TLS} authentication is turned on, which means that all clients are required to provide a certificate signed by the thesis CA in order to establish a connection.

Access Control is also enabled through an explicit \gls{ACL} \footnote{Redis ACL is a new feature released in Redis v6.0}. Following the principle of least privilege, users are defined via an username and a strong password and have permissions to access only the operations that they require to function.

When running in a replicated environment, master-slave or cluster, the same principles apply. Communication between replicas is also always through mutual \gls{TLS} authentication, even in cluster mode where an event bus is necessary for replica synchronisation. Replicas are read-only and since they can connect to the master instance, they use a specific user with permissions to perform just the operations that the replica needs to synchronise, and cannot alter the state of the master instance.

\subsection{Proxy Server}
\label{ssec:proxy_server}

The proxy server is the component that abstracts the Redis configurations in the backend. Proxy is a spring boot starter, version 2.3.0.RELEASE, web server application written in Kotlin v1.4.10, a language that runs on the \gls{JVM} with Java OpenJDK version 11.0.9.

This component serves as a single point of entry to the system, and clients connect to it via an exposed \gls{HTTP} \gls{API} via a \gls{SSL}/\gls{TLS} encrypted channel (\gls{HTTPS}). This connection only authenticates the server, but users need to provide an authorisation header to access the server. The bearer token, on the format of a \gls{JWT} (Json Web Token) must be provided by the external authentication server as the proxy will check with it to validate the request. Not all users can access all endpoints, and the proxy decides the access control based on the role presented in the token.

Using an external configuration file, the proxy is able to communicate with multiple configurations of Redis instances. Communication with the instance is performed via Jedis v3.3.0 \cite{jedis:1}, a simple and lightweight java Redis client. When connecting to a protected Redis instance, an instance secured by \gls{SGX} processor and running inside an enclave, the proxy passes through the keys and values to the instance without any modification, meaning that values are secured inside the enclave even though they are handled in plaintext. However, all data residing on unprotected memory should be encrypted and by enabling a flag in the configuration file, the proxy will encrypt, sign and perform integrity checks on all keys and values. The homomorphic encryption is performed with the help of the Hlib v1.2r2 \cite{homolib:1}, an homomorphic encryption library implemented by the NOVA LINCS developers.

Keys for all value formats (simple, lists, etc..) are always encrypted with the Homomorphic Deterministic (HomoDet) cipher, that guarantees the same encrypted string for the same clear text value. This allows for Redis to match a given key with one present in the storage without revealing the actual value of the key.

The value from the key-value pair is encrypted in a more complex way than the keys, and their format is detailed in \ref{eq:redis_value_encrypted}, \ref{eq:redis_value_signature} and \ref{eq:final_redis_value}.

\begin{eqnarray}
EncryptedValue \  = \  [\: value \: ] \: \textsubscript{Ks} \label{eq:redis_value_encrypted} \\
CompositeValue \  = \  [\: value \: ] \: \textsubscript{Ks} \quad | \quad [\: EncryptedValue \: ] \: \textsubscript{Ksignature} \label{eq:redis_value_signature} \\
\![\: value \: ] \: \textsubscript{Ks} \quad | \quad [\: EncryptedValue \: ] \: \textsubscript{Ksignature} \quad | \quad [ \: CompositeValue \: ] \: \textsubscript{KHmac} \label{eq:final_redis_value}
\end{eqnarray}

The value is encrypted in one of two ways - refering to \ref{eq:redis_value_encrypted}:

\begin{itemize}
  \item \textbf{If the value is a string}, it is encrypted with a strong \gls{AES} cipher working on a \gls{ECB} (Electronic Code Book) mode with a \textit{PKCS5} Padding (\textit{AES/ECB/PKCS5Padding}) from SunJCE provider, with a 256 bit key.
  \item \textbf{If the value is an integer/long/double}, the value is encrypted with the Homomorphic Addition (HomoAdd) cipher from the Hlib library with a Paillier Key.
\end{itemize}

Strings are encrypted with the strongest cipher because no operation will be performed over the encrypted value, but for arithmetic values, the HomoAdd cipher is used, to allow for addition, subtraction and multiplication operations over the encrypted value.

Regardless of the encryption cipher, the encrypted value is signed with a standard SHA512 with \gls{RSA} signature algorithm from the \textit{SunRsaSign} provider - \ref{eq:redis_value_signature}. The signature is performed over the encrypted value to allow the homomorphic operations results being sign without having to decrypt the value. The signature is then appended to the encrypted value and the result is  hashed with a HMacSHA256 algorithm to provide a rapid integrity check. The result of all security operations, encryption, signature and hashing is appended into one string and set into the Redis database as a single value.

When setting a value in a list with a score, the keys and values are secured like explained above, but the scores can also pretend to sensitive data and are also encrypted. However, to provide the capabilities of fetching values between scores, a score is encrypted with the HomoOpeInt cipher from Hlib, an order preserving cipher. This cipher kepts the scores confidential but still preserves order and can be searchable on an inequality operation, for example $ x < score < y $, that fetches all values with scores between an \textit{x} and a \textit{y} number.

For demonstration purposes, when adding a value to a set, on the respective endpoint, the value is encrypted with the HomoSearch cipher from Hlib. This cipher allows searching an encrypted value for a specific substring provided by the client.

The \gls{API}, endpoints and parameters, are completely documented and available on an OpenAPI v3.0.0 \textit{yml} format.

\subsection{Client-based Benchmarks}
\label{ssec:client_based_benchmarks}

\subsection{Authentication Server}
\label{ssec:implementation_authentication_server}

\subsection{Attestation Service}
\label{ssec:attestation_service}

\section{Additional Security Features}
\label{sec:additional_security_features}

\subsection{SCONE debug}
\label{ssec:scone_debug}

\subsection{SSL, HTTPS and Certificate Chain}
\label{ssec:ssl_https_certificate_chain}

\subsection{Logging and Auditing} 
\label{sec:logging_and_auditing}

\section{Tradeoffs on the Implementation Options}
\label{sec:tradeoffs_implementation_options}

Discutir overheads daquilo que usámos (openSSL issue, redis monolitico ou não, etc)

\section{Summary}
\label{sec:chapter4_summary}