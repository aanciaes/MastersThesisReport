%!TEX root = ../template.tex

\chapter{Prototype Implementation}
\label{cha:elaboration_plan}

This chapter presents a detailed explanation of the implementation of the prototype - A Trusted and Privacy-Enhanced In-Memory Data Store, and all the implementation details that helped the system to achieve a secure state according to the adversary model.

Section \ref{sec:architecture_implementation_options} explains the system model presented on figure \ref{fig:system_model_overview} from a developer view, and presents all used technologies, programming languages and implementation details used to achieve the desired system.

Section \ref{sec:additional_security_features} presents some general additional security and implementation features also worth mentioning and in section \ref{sec:tradeoffs_implementation_options} it is explained some tradeoffs decided in the implementation of the prototype, and why where they made. 

To finalise, there is a general summary if the chapter in section \ref{sec:chapter4_summary} that gathers all important implementation features from all components.

The implemented prototype source code is available publicly on GitHub, secure datastore, \cite{thesis-repository:container}, the proxy \cite{thesis-repository:proxy} and the client/tester \cite{thesis-repository:client}.

\section{Architecture and Implementation Options}
\label{sec:architecture_implementation_options}

To achieve the goal of deploying the system in a cloud, we had to find a provider that has and provides host machines with the pretended \gls{TEE} technology - Intel's Software Guard Extensions (\gls{SGX}) v2.11. Although not globally available, some cloud providers are starting to make them available and for this thesis, the cloud provider used is OVH Cloud \cite{ovhcloud:1}. 

For this thesis, OVH provided an IaaS stack machine running Ubuntu Server version 18.04 with kernel 4.15.0-101-generic, which means that we have control over all host's stack but the hardware, from the operating system, networks, runtime and applications. The used machine specific configurations are listed on listing \ref{lst:ovh_machine_specs}.

\lstset{numbers=none, caption=Machine Specifications, label=lst:machine_specs}
\label{lst:ovh_machine_specs}
\begin{lstlisting}
Dedicated Server Node
Processor: Intel 2x Xeon Silver 4214 - 24c/48t - 2.2GHz/3.2Ghz
Memory: 192 GB
Hard Drive: NVMe, SATA available
Public Network: Beginning at 1 Gbps
Private Network: Beginning at 2 Gbps
CloudLinux (Ubuntu 18.04 LTS Server 64 bits)
\end{lstlisting}

This particular Intel processor offers \gls{SGX} with an 128\gls{MB} of enclave page cache (\gls{EPC}) with about 94\gls{MB} being available for application use like explained in section \ref{ssec:circumvention_of_sgx_limitations} and all \gls{SGX} linux drivers and \glspl{SDK} were installed \cite{sgx_drivers:1, sgx_sdk:1}.

All components of the application will be deployed using Docker v19.03.6 \cite{docker:1} and the Docker Compose tool v1.17.1 \cite{docker-compose:1}. To integrate and run unmodified applications with \gls{SGX}, the SCONE v4.2.1 \cite{scone:1} technology was used, and will wrap all components that need to run within a secure and isolated environment.

\subsection{Secure Redis}
\label{ssec:secure_redis}

Redis \cite{redis:1} is the key-value storage server used by this thesis. Redis instances will run in two different modes, as explained in section \ref{ssec:key-value_storage_server}. Unsecure Redis configuration will run on unprotected memory on a docker image based on the official Redis Docker repository \cite{redis:6}. For the secure configuration, SCONE framework already provides a curated image from their repository which contains a Redis server version 6.0-rc1 ready to run on an isolated environment, in this case Intel's SGX. The SCONE version used is the SCONE 4.2.1 to match across all the SCONE components.

Although all redis servers run behind a proxy all the necessary security features provided natively by the server are used. Only communications incoming from the proxy server are allowed and all are encrypted with strong \gls{TLS} 1.3 \footnote{TLS is a new feature released in Redis v6.0} protocols with enclave termination. The non encrypted communication port is disabled, and mutual \gls{TLS} authentication is turned on, which means that all clients are required to provide a certificate signed by the thesis CA in order to establish a connection.

Access Control is also enabled through an explicit \gls{ACL} \footnote{Redis ACL is a new feature released in Redis v6.0}. Following the principle of least privilege, users are defined via an username and a strong password and have permissions to access only the operations that they require to function.

When running in a replicated environment, master-slave or cluster, the same principles apply. Communication between replicas is also always through mutual \gls{TLS} authentication, even in cluster mode where an event bus is necessary for replica synchronisation. Replicas are read-only and since they can connect to the master instance, they use a specific user with permissions to perform just the operations that the replica needs to synchronise, and cannot alter the state of the master instance.

\subsection{Proxy Server}
\label{ssec:proxy_server}

The proxy server is the component that abstracts the Redis configurations in the backend. Proxy is a spring boot starter, version 2.3.0.RELEASE, web server application written in Kotlin v1.4.10, a language that runs on the \gls{JVM} with Java OpenJDK version 11.0.9.

This component serves as a single point of entry to the system, and clients connect to it via an exposed \gls{HTTP} \gls{API} via a \gls{SSL}/\gls{TLS} encrypted channel (\gls{HTTPS}). This connection only authenticates the server, but users need to provide an authorisation header to access the server. The bearer token, on the format of a \gls{JWT} (Json Web Token) must be provided by the external authentication server as the proxy will check with it to validate the request. Not all users can access all endpoints, and the proxy decides the access control based on the role presented in the token.

Using an external configuration file, the proxy is able to communicate with multiple configurations of Redis instances. Communication with the instance is performed via Jedis v3.3.0 \cite{jedis:1}, a simple and lightweight java Redis client. When connecting to a protected Redis instance, an instance secured by \gls{SGX} processor and running inside an enclave, the proxy passes through the keys and values to the instance without any modification, meaning that values are secured inside the enclave even though they are handled in plaintext. However, all data residing on unprotected memory should be encrypted and by enabling a flag in the configuration file, the proxy will encrypt, sign and perform integrity checks on all keys and values. The homomorphic encryption is performed with the help of the Hlib v1.2r2 \cite{homolib:1}, an homomorphic encryption library implemented by the NOVA LINCS developers.

Keys for all value formats (simple, lists, etc..) are always encrypted with the Homomorphic Deterministic (HomoDet) cipher, that guarantees the same encrypted string for the same clear text value. This allows for Redis to match a given key with one present in the storage without revealing the actual value of the key.

The value from the key-value pair is encrypted in a more complex way than the keys, and their format is detailed in \ref{eq:redis_value_encrypted}, \ref{eq:redis_value_signature} and \ref{eq:final_redis_value}.

\begin{eqnarray}
EncryptedValue \  = \  [\: value \: ] \: \textsubscript{Ks} \label{eq:redis_value_encrypted} \\
CompositeValue \  = \  [\: value \: ] \: \textsubscript{Ks} \quad | \quad [\: EncryptedValue \: ] \: \textsubscript{Ksignature} \label{eq:redis_value_signature} \\
\![\: value \: ] \: \textsubscript{Ks} \quad | \quad [\: EncryptedValue \: ] \: \textsubscript{Ksignature} \quad | \quad [ \: CompositeValue \: ] \: \textsubscript{KHmac} \label{eq:final_redis_value}
\end{eqnarray}

The value is encrypted in one of two ways - refering to \ref{eq:redis_value_encrypted}:

\begin{itemize}
  \item \textbf{If the value is a string}, it is encrypted with a strong \gls{AES} cipher working on a \gls{ECB} (Electronic Code Book) mode with a \textit{PKCS5} Padding (\textit{AES/ECB/PKCS5Padding}) from SunJCE provider, with a 256 bit key.
  \item \textbf{If the value is an integer/long/double}, the value is encrypted with the Homomorphic Addition (HomoAdd) cipher from the Hlib library with a Paillier Key.
\end{itemize}

Strings are encrypted with the strongest cipher because no operation will be performed over the encrypted value, but for arithmetic values, the HomoAdd cipher is used, to allow for addition, subtraction and multiplication operations over the encrypted value.

Regardless of the encryption cipher, the encrypted value is signed with a standard SHA512 with \gls{RSA} signature algorithm from the \textit{SunRsaSign} provider - \ref{eq:redis_value_signature}. The signature is performed over the encrypted value to allow the homomorphic operations results being sign without having to decrypt the value. The signature is then appended to the encrypted value and the result is  hashed with a HMacSHA256 algorithm to provide a rapid integrity check. The result of all security operations, encryption, signature and hashing is appended into one string and set into the Redis database as a single value.

When setting a value in a list with a score, the keys and values are secured like explained above, but the scores can also pretend to sensitive data and are also encrypted. However, to provide the capabilities of fetching values between scores, a score is encrypted with the HomoOpeInt cipher from Hlib, an order preserving cipher. This cipher kepts the scores confidential but still preserves order and can be searchable on an inequality operation, for example $ x < score < y $, that fetches all values with scores between an \textit{x} and a \textit{y} number.

For demonstration purposes, when adding a value to a set, on the respective endpoint, the value is encrypted with the HomoSearch cipher from Hlib. This cipher allows searching an encrypted value for a specific substring provided by the client.

The \gls{API}, endpoints and parameters, are completely documented and available on an OpenAPI v3.0.0 \textit{yml} format.

\subsection{Client-based Benchmarks}
\label{ssec:client_based_benchmarks}

As explained before, the client is going to be emulated by a tester. Benchmarks were performed in two different ways: directly against the Redis instances, using the \textbf{redis-benchmark} \cite{redis_benchmark_cli:1} tool, and through the proxy \gls{API}.

This proxy \gls{API} tester is implemented using the Gatling v3.2.1 \cite{gatling:1} framework. Gatling is a load and performance testing tool that is configured as code. The configuration of the tool is written in Scala v2.12.3 and provides a very configurable \gls{API}. It has the ability to generate fields, that will be used to populate the database, and perform as much requests as needed or perform request during  a certain amount of time. This framework also allows to perform the necessary login request to the external authentication server in order to provided the access token to the proxy API.

For performance and load testing we can also make various simultaneous users perform actions at the same time and set up ramp up periods of higher load.

The benchmarks are doing requests to every endpoint available, and will compared against other proxy and database configurations and Gatling provides a detailed report for each one, exposing different metrics that will be presented further down this document in chapter \ref{cha:validation_experimental_Evaluation}.

Also, the same tests were configured on the Apache Jmeter v5.3\cite{jmeter:1} load testing platform to corroborate some results.

\subsection{Authentication Server}
\label{ssec:implementation_authentication_server}

The external authentication server is Keycloak v10.0.2 \cite{keycloak:1}, open source identity and access management from Red Hat. This service implements the current standards for single sing-on, authentication and authorisation security.

Communication is performed over encrypted \gls{HTTPS} channels, and the client logins directly against this server to obtain the access token necessary to access the proxy.

User and roles management is done via the Keycloak user console and the platform allows for the configuration of different access token signing keys, their expiration date and supports token revocation and key rotation.

\subsection{Attestation}
\label{ssec:implementation_of_attestation}

Attestation is performed with two different methods in two different scenarios. The \gls{SGX} attestation and the application software and stack attestation.

\textbf{\gls{SGX} attestation} is performed at startup and its transparent and automatic using physical \gls{SGX} \gls{EPID}-based attestation between the locally deployed attestation service, the SCONE \gls{LAS} and the remote SCONE \gls{CAS}. 

The Configuration and Attestation Service \gls{CAS} will hold some application secret, in case of the Redis instance, the \gls{TLS} private and public keys, in case of the attestation server running alongside Redis, the software stack attestation quote signing keys, and assign access control policies to the secrets where only an attested enclave with a know and configured enclave hash can access. So, at start up, both containers will try and fetch these secrets from the \gls{CAS}. To do so, enclaves must prove that they meet the access control policies set by \gls{CAS} to access the secrets, and the \gls{SGX} attestation between both enclaves starts. When the attestation succeeds, the requested secrets are stored inside the requesting enclave and nowhere else, meaning that no human or process, regardless of their roles in the system will be able to access the secrets. In case of Redis, if it is able to provide the right certificates on a \gls{HTTPS} connection, that means that the enclave was attested and its correct. The same goes for the application and software stack attestation and its signing keys.

\textbf{The application software and stack attestation} relies on the first type attestation in order to access the keys necessary to operate, and it is performed at user request. This attestation is meant to attest binaries, config files, hardware and \gls{OS} information to the client by providing signed hashes of those resources. The client then decides if they match and pass the expected integrity checks, and if sign with a key provided by the \gls{CAS}.

This attestation service was implemented in C++14 for the Redis instances, compiled using \textit{Linux Musl g++} GNU Compiler Collection (GCC) version 10.2.0 using the Linux Chilkat C/C++ Library v9.5.0.84 statically linked to the code in order to run totally inside the enclave, and Koltin for the proxy server.

\section{Additional Security Features}
\label{sec:additional_security_features}

\subsection{SCONE debug}
\label{ssec:scone_debug}

\subsection{SSL, HTTPS and Certificate Chain}
\label{ssec:ssl_https_certificate_chain}

\subsection{Logging and Auditing} 
\label{sec:logging_and_auditing}

\section{Tradeoffs on the Implementation Options}
\label{sec:tradeoffs_implementation_options}

Discutir overheads daquilo que usámos (openSSL issue, redis monolitico ou não, etc)

\section{Summary}
\label{sec:chapter4_summary}